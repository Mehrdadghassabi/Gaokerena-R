# بازی واژگان مبتنی بر فضای تعبیه (Word Embedding Game)

## شرح بازی

این بازی یک بازی واژگان ساده است که بر اساس فاصله‌های معنایی بین کلمات در فضای تعبیه عمل می‌کند:

### قوانین بازی:
1. در ابتدا دو واژه خاص (α) توسط برنامه پیشنهاد می‌شود
2. بازیکن باید واژه‌ای (β) پیشنهاد دهد که:
   - حداقل فاصله α از یکی از واژگان موجود داشته باشد
   - حداکثر فاصله β از تمام واژگان موجود داشته باشد
3. بازی تا زمانی ادامه می‌یابد که فاصله بین تمام واژگان کمتر از β شود

## روش پیشنهادی: Word2Vec

### چرا Word2Vec؟

**Word2Vec** به عنوان روش نگاشت واژگان به فضای تعبیه پیشنهاد می‌شود زیرا:

#### مزایای Word2Vec نسبت به Bag of Words (BOW):

1. **درنظرگیری روابط معنایی**: 
   - BOW فقط فراوانی کلمات را در نظر می‌گیرد
   - Word2Vec روابط معنایی و سیاق کلمات را درنظر می‌گیرد

2. **کاهش ابعاد**:
   - BOW منجر به فضای پراکنده و پربعد می‌شود
   - Word2Vec فضایی متصل و کم‌بعد (معمولاً 100-300 بعد) ایجاد می‌کند

3. **کیفیت بازنمایی**:
   - کلمات مشابه در Word2Vec نزدیک به هم قرار می‌گیرند
   - BOW این خاصیت را ندارد

### خصوصیات مورد نیاز روش تعبیه:

1. **حفظ روابط معنایی**: کلمات مشابه باید نزدیک به هم باشند
2. **پایداری**: بازنمایی کلمات باید قابل اعتماد باشد
3. **قابلیت محاسبه فاصله**: امکان محاسبه فاصله بین بردارها
4. **کارایی محاسباتی**: سرعت مناسب برای بازی

### فرمول‌های فاصله قابل استفاده:

#### 1. فاصله اقلیدسی (Euclidean Distance):
```
d(u,v) = √(Σ(ui - vi)²)
```

#### 2. فاصله منهتن (Manhattan Distance):
```
d(u,v) = Σ|ui - vi|
```

#### 3. شباهت کسینوسی (Cosine Similarity):
```
similarity(u,v) = (u·v) / (||u|| × ||v||)
distance(u,v) = 1 - similarity(u,v)
```

## انتخاب نهایی: Cosine Similarity

### چرا Cosine Similarity؟

1. **مقاوم در برابر طول بردار**: فقط جهت بردارها را در نظر می‌گیرد، نه اندازه آن‌ها
2. **مناسب برای Word2Vec**: با ماهیت Word2Vec سازگاری بیشتری دارد
3. **بازه مشخص**: مقادیر بین -1 تا 1 (یا 0 تا 1 برای فاصله)
4. **تفسیرپذیری**: مفهوم شباهت زاویه‌ای قابل فهم است

### پیاده‌سازی پیشنهادی:

```python
import numpy as np
from gensim.models import Word2Vec
from sklearn.metrics.pairwise import cosine_similarity

def calculate_distance(word1, word2, model):
    """محاسبه فاصله کسینوسی بین دو کلمه"""
    vec1 = model.wv[word1].reshape(1, -1)
    vec2 = model.wv[word2].reshape(1, -1)
    similarity = cosine_similarity(vec1, vec2)[0][0]
    return 1 - similarity  # تبدیل شباهت به فاصله

def check_game_rules(new_word, existing_words, model, alpha, beta):
    """بررسی قوانین بازی"""
    distances = [calculate_distance(new_word, word, model) 
                for word in existing_words]
    
    # بررسی شرط حداقل فاصله α
    min_distance = min(distances)
    if min_distance < alpha:
        return False, "فاصله کمتر از حد مجاز α"
    
    # بررسی شرط حداکثر فاصله β
    max_distance = max(distances)
    if max_distance > beta:
        return False, "فاصله بیشتر از حد مجاز β"
    
    return True, "کلمه قابل قبول است"
```

## نتیجه‌گیری

ترکیب **Word2Vec** و **Cosine Similarity** بهترین انتخاب برای این بازی است زیرا:
- روابط معنایی کلمات را حفظ می‌کند
- محاسبات سریع و کارآمد دارد
- برای بازی تعاملی مناسب است
- نتایج قابل تفسیر و منطقی ارائه می‌دهد
